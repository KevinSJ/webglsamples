<!--
 * Copyright 2009, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>WebGL SpaceRocks</title>
<style>
body {
  width: 100%;
  height: 100%;
  border: 0px;
  padding: 0px;
  margin: 0px;
  background-color: red;
}
CANVAS {
  background-color: gray;
}
</style>
<script type="text/javascript" src="js/webgl-test-utils.js"></script>
<script type="text/javascript" src="js/webgl-debug.js"></script>
<script type="text/javascript" src="../tdl/base.js"></script>
<script type="text/javascript">
tdl.require('tdl.buffers');
tdl.require('tdl.math');
tdl.require('tdl.primitives');
tdl.require('tdl.programs');
tdl.require('tdl.textures');
window.onload = initialize;

// globals
var gl;                   // the gl context.
var wu = WebGLTestUtils;  // some webgl utils
var wd = WebGLDebugUtils; // more webgl utils
var canvas;               // the canvas
var math;                 // the math lib.

function createProgramFromTags(vertexTagId, fragmentTagId) {
  return new tdl.programs.Program(
      document.getElementById(vertexTagId).text,
      document.getElementById(fragmentTagId).text);
}

function flatten(array){
  var flat = [];
  for (var i = 0, l = array.length; i < l; i++) {
    var type = Object.prototype.toString.call(array[i]).split(' ').pop().split(']').shift().toLowerCase();
    if (type) { flat = flat.concat(/^(array|collection|arguments|object)$/.test(type) ? flatten(array[i]) : array[i]); }
  }
  return flat;
}

function initialize() {
  math = tdl.math;
  canvas = document.getElementById("canvas");
  gl = wu.create3DContext(canvas);
  gl = wd.makeDebugContext(gl);
  gl.disable(gl.BLEND);
  gl.enable(gl.DEPTH_TEST);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, gl.TRUE);
  updateOb = {
    update: function() { }
  };
  var colorMap = new tdl.textures.Texture('assets/rock-color.png', updateOb);
  var normalMap = new tdl.textures.Texture('assets/rock-nmap.png', updateOb);
  program = createProgramFromTags(
      'normalMapVertexShader',
      'normalMapFragmentShader');
  arrays = tdl.primitives.createBumpmapSphere(1, 30, 30);
  buffers = { };
  for (name in arrays) {
    var target = (name == 'indices') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
    var b = new tdl.buffers.Buffer(arrays[name], target);
    buffers[name] = b;
  }
  program.use();
  for (buffer in buffers) {
    if (buffer == 'indices') {
      continue;
    }
    var b = buffers[buffer];
    program.attrib[buffer](b);
  }

  var eyePosition = [3, 4, 14];
  var lightPosition = [6, 9, 14];
  var projection = math.matrix4.perspective(
      math.degToRad(30),
      canvas.clientWidth / canvas.clientHeight,
      1,
      5000);
  var view = math.matrix4.lookAt(
      eyePosition,
      [0, 0, 0],
      [0, 1, 0]);
  var world = math.matrix4.identity();
  var viewProjection = math.matrix4.mul(view, projection);
  var worldViewProjection = math.matrix4.mul(world, viewProjection);
  var viewInverse = math.matrix4.inverse(view);
  var worldInverse = math.matrix4.inverse(world);
  var worldInverseTranspose = math.transpose(worldInverse);
  //console.log("world:" + world);
  //console.log("view:" + view);
  //console.log("projection:" + projection);
  //console.log("viewProjection:" + viewProjection);
  //console.log("wvp:" + worldViewProjection);

  program.setUniform('worldViewProjection', flatten(worldViewProjection));
  program.setUniform('lightColor', [1,1,1,1]);
  program.setUniform('lightWorldPos', lightPosition);
  program.setUniform('world', flatten(world));
  program.setUniform('viewInverse', flatten(viewInverse));
  program.setUniform('worldInverseTranspose', flatten(worldInverseTranspose));
  program.setUniform('emissive', [0,0,0,1]);
  program.setUniform('ambient', [0,0,0,0]);
  program.setUniform('specular', [1,1,1,1]);
  program.setUniform('shininess', 50);
  program.setUniform('specularFactor', 1.3);
  program.setUniform('diffuseSampler', 0);
  program.setUniform('bumpSampler', 1);

  updateOb.update = render;
  render();

  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    colorMap.bindToUnit(0);
    normalMap.bindToUnit(1);
    gl.drawElements(gl.TRIANGLES, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);
  }

}
</script>
</head>
<body>
<canvas id="canvas" width="1024" height="1024" style="width: 100%; height: 100%;"></canvas>
</body>
<!--
<script id="constVertexShader" type="text/something-not-javascript">
attribute vec4 position;
//attribute vec3 normal;
//attribute vec2 texCoord;
//varying vec2 v_texCoord;
//varying vec3 v_normal;
uniform mat4 worldViewProjection;
void main() {
  //v_texCoord = texCoord;
  //v_normal = normal;
  gl_Position = (worldViewProjection * position);
}
</script>
<script id="constFragmentShader" type="text/something-not-javascript">
#ifdef GL_ES
precision highp float;
#endif
//varying vec2 v_texCoord;
//varying vec3 v_normal;
void main() {
//  gl_FragColor = vec4(vec3(v_texCoord, 1) + v_normal, 1);
  gl_FragColor = vec4(1, 1, 0, 1);
}
</script>
-->
<script id="normalMapVertexShader" type="text/something-not-javascript">
uniform mat4 worldViewProjection;
uniform vec3 lightWorldPos;
uniform mat4 world;
uniform mat4 viewInverse;
uniform mat4 worldInverseTranspose;
attribute vec4 position;
attribute vec3 normal;
attribute vec2 texCoord;
attribute vec3 tangent;
attribute vec3 binormal;
varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_tangent;
varying vec3 v_binormal;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;
void main() {
  v_texCoord = texCoord;
  v_position = (worldViewProjection * position);
  v_normal = (worldInverseTranspose * vec4(normal, 0)).xyz;
  v_surfaceToLight = lightWorldPos - (world * position).xyz;
  v_surfaceToView = (viewInverse[3] - (world * position)).xyz;
  v_binormal = (worldInverseTranspose * vec4(binormal, 0)).xyz;
  v_tangent = (worldInverseTranspose * vec4(tangent, 0)).xyz;
  gl_Position = v_position;
}

</script>
<script id="normalMapFragmentShader" type="text/something-not-javascript">
#ifdef GL_ES
precision highp float;
#endif
uniform vec4 lightColor;
varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_tangent;
varying vec3 v_binormal;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 emissive;
uniform vec4 ambient;
uniform sampler2D diffuseSampler;
uniform vec4 specular;
uniform sampler2D bumpSampler;
uniform float shininess;
uniform float specularFactor;

vec4 lit(float l ,float h, float m) {
  return vec4(1.0,
              max(l, 0.0),
              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
              1.0);
}
void main() {
  vec4 diffuse = texture2D(diffuseSampler, v_texCoord);
  mat3 tangentToWorld = mat3(v_tangent,
                             v_binormal,
                             v_normal);
  vec3 tangentNormal = texture2D(bumpSampler, v_texCoord.xy).xyz -
                                 vec3(0.5, 0.5, 0.5);
  vec3 normal = (tangentToWorld * tangentNormal);
  normal = normalize(normal);
  vec3 surfaceToLight = normalize(v_surfaceToLight);
  vec3 surfaceToView = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLight + surfaceToView);
  vec4 litR = lit(dot(normal, surfaceToLight),
                    dot(normal, halfVector), shininess);
  gl_FragColor = vec4((emissive +
  lightColor * (ambient * diffuse + diffuse * litR.y +
                        + specular * litR.z * specularFactor)).rgb,
      diffuse.a);
}
</script>
</html>


